<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Do sth. Slowly</title>
    <link>/post/</link>
    <description>Recent content in Posts on Do sth. Slowly</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 30 Dec 2019 16:27:00 +0800</lastBuildDate>
    
	<atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Some games I play</title>
      <link>/post/random-games/</link>
      <pubDate>Mon, 30 Dec 2019 16:27:00 +0800</pubDate>
      
      <guid>/post/random-games/</guid>
      <description>上周六买的 PS4 Pro 终于到了，本来以为上午就能到，到过一直等到下午都还没有到，出去吃饭的时候，看到一个大箱子在门口挡着，也不知道什么时候到的，顺丰送货原来连电话都不打一个的（
买的两个游戏在 PS4 前一天就到了，本来包装的箱子不大，但是顺丰的包装大概是原来的箱子的几倍吧，填充了很多防震的东西。
DONE风之旅人 第一次玩这个游戏，也不还太会用 PS4。整个过程真是太美了，风景特别好看，体验特别好，过程中不断发出惊叹，原来游戏还可以这么美。
基本上一晚上就打通关了，途中碰见了另外一个人，一起在某一关的最后静坐了一会儿，很新奇。
说起来整个过程是没有声音的，我还以为游戏本来就没有声音，后来才知道，原来是音频设置的问题。
TODO荒野大镖客：救赎2 刚刚开始玩，这个游戏看起来适合有整块时间的时候玩。
两个游戏玩的过程中并没有上瘾的感觉，只是觉得画面好优美，体验极好，感觉更适合消遣，不过这大概也是游戏的目的吧。</description>
    </item>
    
    <item>
      <title>LeetCode 25. K 个一组翻转链表</title>
      <link>/post/leetcode-25/</link>
      <pubDate>Thu, 12 Dec 2019 19:05:00 +0800</pubDate>
      
      <guid>/post/leetcode-25/</guid>
      <description>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
k 是一个正整数，它的值小于或等于链表的长度。
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
示例 :
给定这个链表：1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5
当 k = 2 时，应当返回: 2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;5
当 k = 3 时，应当返回: 3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5
说明 :
你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 做这道题目的时候错了几次，这道题目不难，关键点是对细节和边界条件的处理。这道题目基本是反转链表的变形。
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { if (head == nullptr) return head; using lp = ListNode*; lp t1, t2, tmp, t3 = head, pt = nullptr; int cnt = 0; while (true &amp;amp;&amp;amp; t3 !</description>
    </item>
    
    <item>
      <title>LeetCode 1043. 分隔数组以得到最大和</title>
      <link>/post/leetcode-1043/</link>
      <pubDate>Thu, 12 Dec 2019 11:54:00 +0800</pubDate>
      
      <guid>/post/leetcode-1043/</guid>
      <description>给出整数数组 A，将该数组分隔为长度最多为 K 的几个（连续）子数组。分隔完成后，每个子数组的中的值都会变为该子数组中的最大值。
返回给定数组完成分隔后的最大和。
示例：
输入：A = [1,15,7,9,2,5,10], K = 3 输出：84 解释：A 变为 [15,15,15,9,10,10,10]
提示：
1 &amp;lt;= K &amp;lt;= A.length &amp;lt;= 500 0 &amp;lt;= A[i] &amp;lt;= 10^6
来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/partition-array-for-maximum-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 看到这道题目一开始是在群里，发了英文版的这道题目，大概看了一下，以为是分割成最多 K 个子数组，然后写了一下，最后提交当然是答案错误，反推错误的样例，发现没错啊，然后再看中文题意，发现理解错了。本意是每个子数组长度最多是 K ，然后就没啥思路了。猜想是 DP，可是也没有构造出状态，最后没有做出来。群里人说确实是 DP，然后我瞄了一眼题解，确实很多都是 DP 来做的，自己又朝着 DP 的方向思考，还是没有想出来。今天上午又开始想这道题目：既然是 DP，并且看题解也不是一道复杂的 DP，那么状态应该很简单，只需要构造出一个状态，满足：最优子结构、无后效性即可。然后就开始假设状态，思考决策的过程应该检查哪些状态，有哪些条件，哪些条件是必须的，哪些条件是不需要保存的，对于下一个状态，是不是只和上一个（或者多个）状态的结果有关。最后想到可以用 dp[i] 来表示前 i 个数字的最优解，开始以为也需要保存以第 i 个数字结尾的子数组的长度，后来发现下一个状态并不需要这个东西，因为下一个数字加入进来的时候，并不需要延展以第 i 个数字结尾的子数组，它只需要作为一个以第 i+1 个数字的新数组向左延展就好了，最多延展的长度是 K ，这样可以保证遍历到所有的上一个状态。这样就可以得到最优解即 dp[n] 。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;functional&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; using VI = vector&amp;lt;int&amp;gt;; using PII = pair&amp;lt;int, int&amp;gt;; class Solution { public: int maxSumAfterPartitioning(vector&amp;lt;int&amp;gt;&amp;amp; A, int K) { int len = int(A.</description>
    </item>
    
    <item>
      <title>LeetCode 1282. 用户分组</title>
      <link>/post/leetcode-1282/</link>
      <pubDate>Tue, 10 Dec 2019 16:03:00 +0800</pubDate>
      
      <guid>/post/leetcode-1282/</guid>
      <description>有 n 位用户参加活动，他们的 ID 从 0 到 n - 1，每位用户都 恰好 属于某一用户组。给你一个长度为 n 的数组 groupSizes，其中包含每位用户所处的用户组的大小，请你返回用户分组情况（存在的用户组以及每个组中用户的 ID）。
你可以任何顺序返回解决方案，ID 的顺序也不受限制。此外，题目给出的数据保证至少存在一种解决方案。
示例 1：
输入：groupSizes = [3,3,3,3,3,1,3] 输出：[[5],[0,1,2],[3,4,6]] 解释：其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。
示例 2：
输入：groupSizes = [2,1,3,3,3,2] 输出：[[1],[0,5],[2,3,4]]
提示：
groupSizes.length = n 1 &amp;lt; n &amp;lt;= 500 1 &amp;lt;= groupSizes[i] &amp;lt;= n
来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/group-the-people-given-the-group-size-they-belong-to 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 这道题目可以说没有任何难度，把组人数相同的人放在一起然后分组即可。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;unordered_map&amp;gt;using namespace std; using VI = vector&amp;lt;int&amp;gt;; class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; groupThePeople(vector&amp;lt;int&amp;gt;&amp;amp; groupSizes) { unordered_map&amp;lt;int, VI&amp;gt; people; for (size_t i = 0; i &amp;lt; groupSizes.</description>
    </item>
    
    <item>
      <title>LeetCode 1283. 使结果不超过阈值的最小除数</title>
      <link>/post/leetcode-1283/</link>
      <pubDate>Tue, 10 Dec 2019 14:59:00 +0800</pubDate>
      
      <guid>/post/leetcode-1283/</guid>
      <description>1283. 使结果不超过阈值的最小除数
 给你一个整数数组 nums 和一个正整数 threshold ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。
请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。
每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。
题目保证一定有解。
来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-the-smallest-divisor-given-a-threshold 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 这题开始我也没有思路，然后瞄了一眼题解，说是二分。然后自己朝着二分的思路想，发现确实可以二分来做。首先我们知道，当 x 比较大的时候，肯定是一个解，当 x 越大，整个数列的和越小，也就是 F(x) 是递减的，我们需要找到最小的 x 使得 F(x) &amp;lt;= threshold 。由于这个函数单调递减，我们可以考虑二分的思路：首先确定 x 的范围，然后在这个范围中二分；首先，考虑 x 的最大值，原来数组中的最大值一定是解，所以可以把它当作最大值；再考虑 x 的最小值，把原来的数组排序，假设前 n-1 项除以 x 的值都是 1，那么此时第 n 项的值最大，此时对应的 x 值最小，此时 x 为 a[n - 1] / (threshold - (n - 1)) 。剩下的就是写出正确的二分了，注意考虑边界条件，不要死循环。
using VI = vector&amp;lt;int&amp;gt;; class Solution { public: int smallestDivisor(vector&amp;lt;int&amp;gt;&amp;amp; nums, int threshold) { sort(nums.</description>
    </item>
    
    <item>
      <title>Some books I read (or want to read)</title>
      <link>/post/random-books/</link>
      <pubDate>Mon, 02 Dec 2019 14:33:00 +0800</pubDate>
      
      <guid>/post/random-books/</guid>
      <description>列出一些读过、正在读或者想读的书。
DONE棋王·树王·孩子王 阿城
&amp;lt;2019-12-02 一 14:41&amp;gt;这本书写得极好。文字清新优美，人物描写极其生动，读起来非常舒适，大概能够感受到那种文学的美。棋王看了至少三遍，树王由于过于压抑，看过第一遍之后不敢看第二遍，前些天看第二遍的时候，看了一般，然后隔了很久才继续看下去，才淡化那种压抑的感觉。孩子王只看过一遍，非常好看，我想我还会读第二遍。
TODOThe Go Programming Language 这本书之前看过了大部分，只是基本都忘记了。最近正在重新读，希望能够做一些笔记。
DONE我们生活在巨大的差距里 余华
&amp;lt;2019-12-02 一 14:33&amp;gt;昨天拿出吃灰已久的 kindle 在地铁看，无意间翻到的。读起来竟然非常好看，两天利用路上的时间已读完三分之一。我想，以后还会读余华的其它作品。
&amp;lt;2019-12-04 三 18:19&amp;gt;这本书讲了很多文学的故事，甚至激发起了我的阅读欲望，简直就是一个书单。
&amp;lt;2019-12-09 一 11:54&amp;gt;今天早上在上班路上读完了这本书，后面讲了不少足球和篮球比赛还有旅游日记之类的东西，读起来索然无味。最后的两个附录没有读。因为我并没有看过提到的那两篇小说，以后再读也不迟。总得来说，前面讲文学的还不错，后面的球赛的甚至可以不看。
TODO黄金时代 王小波
DONE黄金时代 &amp;lt;2019-12-10 二 11:57&amp;gt;今天上班路上开始看这本书，原因还是 Kindle 里面恰好有这本书，好长时间也没有读。我发现自己读好多书的原因都是这样，Kindle 里面恰好有，或者手边恰好有这本书，然后就读了下去。如果带有很强的目的性，比如这周打算看哪本书，那是肯定看不下去的。另外一方面确实是 Kindle 阅读体验好，携带方便，实体书实在是没有时间和精力维护。
话说这本书好有意思，开头一部分就非常好看，阅读过程简直是享受。话说几年以前也尝试看过这本书，当时没有看下去，现在读来却极有乐趣。我想文学的乐趣就是这样，一本书之前读味同嚼蜡，过一段时间再读却津津有味。
很多时候阅读的乐趣在于，书里的某个场景、某段描写让自己想到了自己很久以前，也有过同样的感受，勾起了自己一段美好的回忆。在上班路上，熙熙攘攘的人群中，仿佛感觉处在另外一个世界。
&amp;lt;2019-12-11 三 15:13&amp;gt;今天利用午休时间，看完了这篇小说（这本书后面还有两个长篇）。说实话并没有怎么看懂，印象深刻的就是那些「敦伟大友谊」、「想变成天上或明或暗的云」之类的句子。不过，整体阅读感受还是挺愉快的，如果是上学时候读到这本书，肯定和现在不一样。
TODO三十而立 &amp;lt;2019-12-12 四 11:10&amp;gt;今天开始读这本书的第二个短篇，开头还挺有趣，好像王小波的书读起来都特别舒服欢快。
TODOOperating System Concepts, 9th Edition &amp;lt;2019-12-12 四 11:16&amp;gt;上周开始阅读这本书，英文版本的，读起来挺舒适，只不过有点儿枯燥，第一章还没有读完。</description>
    </item>
    
    <item>
      <title>Some random thoughts</title>
      <link>/post/random-thoughts/</link>
      <pubDate>Mon, 02 Dec 2019 11:43:00 +0800</pubDate>
      
      <guid>/post/random-thoughts/</guid>
      <description>&amp;lt;2019-12-02 一 11:47&amp;gt; 读书一定要作笔记，否则读过之后过一周，基本就会忘记。技术书尤甚。作笔记的过程也是整理和内化知识的过程，可以帮助理解和记忆。笔记不一定要十分详细，但是一定要有自己的思考。
多阅读其他人的代码，其它项目的代码，学习设计思想和编码技巧。水平提高之后，尝试去阅读开源项目的代码，从项目中学习。
&amp;lt;2019-12-04 三 18:06&amp;gt;这两天发现 MacBook Air 2013 总是时不时风扇狂转，看 Monitor 发现是 WindowServer 这个进程占用 CPU 比较高，过一会儿就恢复了，再过一会儿又开始，循环往复。去搜了一下，试过了各种方法：禁用掉透明效果等，都没有用。猜是不是因为新版本系统 Catalina 的问题，是不是要重新安装一下旧版本的系统，不过又太麻烦了。后来看到一篇文章说这个进程可能和绘制窗口和图像有关，如果外接了显示器可能也会造成这个进程 CPU 占用提高。然后我把外接显示器断开，过了一会儿发现没有那个问题了。问题解决！
中午去公司另外一个办公地点，等人的时候发现墙边的借书架上有一本计算机程序设计的艺术，第四卷组合数学，中文版的，纸张很不错，无聊就读了前言，看起来好厉害。
&amp;lt;2019-12-12 四 11:11&amp;gt;有多久没有体会到编程的乐趣了？是不是更多时候是复制粘贴？有没有思考过背后的实现原理？多久没有认真读一本书了？有没有坚持读下去？有没有做过总结？我觉得这是值得思考的问题。我想趁着现在还有精力和力气，还没有完全变老，想学习有趣的东西，想玩有趣的东西，想学最艰深难懂的知识，想做一些有趣无用的事情。</description>
    </item>
    
    <item>
      <title>LeetCode 1268. 搜索推荐系统</title>
      <link>/post/leetcode-1268/</link>
      <pubDate>Wed, 27 Nov 2019 00:00:00 +0800</pubDate>
      
      <guid>/post/leetcode-1268/</guid>
      <description>LeetCode 1268. 搜索推荐系统
输入一个词典，然后输入一个单词，对于单词的每一个前缀，输出字典中以这个前缀开始的单词的字典序最小的 3 个单词。词典长度 1000，词典中每个单词的长度 20000，目标单词长度 1000.
这道题目开始的想法是字典树。可是数据集的范围太大，字典树占用空间太大。然而也没有想到什么好的方法，最后还是用常规的字典树写了一下，竟然过了。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;stack&amp;gt; using namespace std; using VS = vector&amp;lt;string&amp;gt;; struct TrieTree { char value; bool is_end; TrieTree *children[26]; TrieTree() { for (int i = 0; i &amp;lt; 26; i++) children[i] = nullptr; is_end = false; } }; void insert_word(TrieTree *root, string s) { for (auto x: s) { int pos = x - &amp;#39;a&amp;#39;; if (nullptr != root-&amp;gt;children[pos]) { root = root-&amp;gt;children[pos]; } else { TrieTree *tmp = new TrieTree(); tmp-&amp;gt;value = x; root-&amp;gt;children[pos] = tmp; root = tmp; } } root-&amp;gt;is_end = true; } void print_tree(TrieTree *root, string s, vector&amp;lt;string&amp;gt; &amp;amp;words) { for (int i = 0; i &amp;lt; 26; i++) { TrieTree *child = root-&amp;gt;children[i]; if (nullptr !</description>
    </item>
    
    <item>
      <title>LeetCode LCP 3. 机器人大冒险</title>
      <link>/post/leetcode-lcp-3/</link>
      <pubDate>Tue, 26 Nov 2019 00:00:00 +0800</pubDate>
      
      <guid>/post/leetcode-lcp-3/</guid>
      <description>LeetCode LCP 3. 机器人大冒险
这道题目考察对循环节的理解。开始想得有点儿复杂，分析之后可以发现，关键是如何判断某个点是否在路径上。由于坐标范围过大，显然不能把整条路径计算出来。但是由于整个路径是由相同的路径连起来的，所以考虑循环节。对于一个障碍，找到这个点对应的循环节的起点，然后从起点开始，按照命令把这个循环节里面的点都求一遍，如果某个点能够和这个障碍相等，那么说明可以碰到障碍。对于终点，同样的处理方式，如果所在循环节中的某个点和终点相等，那么说明可以到达终点。命令的个数是 10^3 障碍个数也是 10^3 所以整个复杂度是 10^6 。这是可以接受的。
可以看出整个过程主要的复杂度是如何判断某个障碍是否和对应的循环节中的某个点重合。
上面这种对循环节的处理方式不是很优雅，其实可以把任何一个循环节都对应到第一个循环，然后把这个循环节对应的障碍点也对应到第一个循环节的范围中。这样可以就把第一个循环节的所有的点放到集合中，然后只需要判断障碍点是不是在集合中即可。把点放到集合中的处理方式有很多，可以拼接成字符串，也可以通过其它处理方式，只要保证是一一映射即可。讨论区中看到一种比较有趣的做法，对于一个点 (x, y) 把它映射成一个整数 (long)(x) &amp;lt;&amp;lt; 30 | y 这是由于题目中点的坐标范围是 10^9 而 10^9 &amp;lt; (1L &amp;lt;&amp;lt; 30) ，所以这可以保证是一一映射。
把任何一个点映射到第一个循环节中的点的方式：找到它所在的第 N 个循环节，然后横纵坐标分别减去 N * deltax 和 N * deltay ，其中 deltax 是在一个循环节中横座标的增量。
所以说做题的时候，有的时候虽然能够做出来，可是还是不能够想到最简单和最优雅的处理方式。还是需要多练习和积累经验。一道题目是值得多次做的，做过第一遍之后，以后应该写出最优的解法和实现方式。
#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;cmath&amp;gt; using namespace std; class Solution { public: int deltax, deltay; bool robot(string command, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; obstacles, int x, int y) { deltax = 0, deltay = 0; for (auto i: command) if (i == &amp;#39;U&amp;#39;) deltay++; else deltax++; for (auto i: obstacles) { if (i[0] &amp;gt; x || i[1] &amp;gt; y) continue; if (check(command, i[0], i[1])) return false; } return check(command, x, y); } bool check(string cmd, int x, int y) { int N, startx, starty, N1; if (cmd[0] == &amp;#39;U&amp;#39;) { N = ceil(1.</description>
    </item>
    
    <item>
      <title>Some random links</title>
      <link>/post/random-links/</link>
      <pubDate>Tue, 26 Nov 2019 00:00:00 +0800</pubDate>
      
      <guid>/post/random-links/</guid>
      <description>There are some random interesting links I found on the Internet.
 matrix67  考据癖 虎兔手记   BYVoid MaskRay Ruchee 的荒草园子 How I Switched To Plan 9 An overview of the monad EMACS-DOCUMENT Jack Baty&#39;s weblog Ken Grimes Computer are the Devil Real World Examples blogs using hugo Blogger Bust ZHENG Zi&#39;ou 零壹軒·笔记 wicast&#39;s TNT Pygments style gallery 鸟窝 木子 eschulte public void  Learning resources:
 forum.fast.ai course fast.</description>
    </item>
    
    <item>
      <title>Something About Emacs</title>
      <link>/post/sth-about-emacs/</link>
      <pubDate>Mon, 25 Nov 2019 00:00:00 +0800</pubDate>
      
      <guid>/post/sth-about-emacs/</guid>
      <description>In this series, I will write something about Emacs.
motion commands of c-mode
   Keystokes Command name Action     C-M-a beginning-of-defun Move to the beginning of the body of the function   C-M-e end-of-defun Move to the end of the function   C-M-h c-mark-function Put the cursor at the beginning of the function, the mark at the end   C-c C-q c-indent-defun Indent the entire function according to indention style    Eshell  Mastering Eshell Eschewing Zshell for Emacs Shell howardabrams dot-files WikiEmacs Eshell     Keystrokes Command name Action     C-c M-b eshell-insert-buffer-name Insert the printed buffer name at point   C-c M-v eshell-insert-envvar Inserts an environment variable name at point    Eshell pseudo-devices:</description>
    </item>
    
    <item>
      <title>start a new blog</title>
      <link>/post/start-a-new-blog/</link>
      <pubDate>Mon, 25 Nov 2019 00:00:00 +0800</pubDate>
      
      <guid>/post/start-a-new-blog/</guid>
      <description>generate ssh-keygen For more information, please refer to this.
λ ssh-keygen -t rsa -b 4096 -C &amp;#34;thanks_music163@163.com&amp;#34;   Add public key to github
  Add ssh configuration
Host github-thanks_music HostName github.com User git IdentityFile ~/.ssh/id_rsa_thanks_music   install Emacs package ox-hugo
M-x list-packages or use-package:
(use-package ox-hugo :ensure t :after ox) Refer to document ox-hugo.
  install hugo on macOS:
brew update; and brew install hugo Read the document about Hugo.</description>
    </item>
    
  </channel>
</rss>