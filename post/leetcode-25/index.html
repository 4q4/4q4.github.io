<!DOCTYPE html>
<html lang="zh-CN">

<head>
<meta charset="utf-8" />
<meta name="author" content="4q4" />
<meta name="description" content="" />
<meta name="keywords" content="" />
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.60.0" />

<link rel="canonical" href="/post/leetcode-25/">
<meta property="og:title" content="LeetCode 25. K 个一组翻转链表" />
<meta property="og:description" content="给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
k 是一个正整数，它的值小于或等于链表的长度。
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
示例 :
给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5
当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5
当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5
说明 :
你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 做这道题目的时候错了几次，这道题目不难，关键点是对细节和边界条件的处理。这道题目基本是反转链表的变形。
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { if (head == nullptr) return head; using lp = ListNode*; lp t1, t2, tmp, t3 = head, pt = nullptr; int cnt = 0; while (true &amp;&amp; t3 !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/leetcode-25/" />
<meta property="article:published_time" content="2019-12-12T19:05:00+08:00" />
<meta property="article:modified_time" content="2019-12-30T16:58:45+08:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCode 25. K 个一组翻转链表"/>
<meta name="twitter:description" content="给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
k 是一个正整数，它的值小于或等于链表的长度。
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
示例 :
给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5
当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5
当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5
说明 :
你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 做这道题目的时候错了几次，这道题目不难，关键点是对细节和边界条件的处理。这道题目基本是反转链表的变形。
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { if (head == nullptr) return head; using lp = ListNode*; lp t1, t2, tmp, t3 = head, pt = nullptr; int cnt = 0; while (true &amp;&amp; t3 !"/>


<meta itemprop="name" content="LeetCode 25. K 个一组翻转链表">
<meta itemprop="description" content="给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
k 是一个正整数，它的值小于或等于链表的长度。
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
示例 :
给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5
当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5
当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5
说明 :
你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 做这道题目的时候错了几次，这道题目不难，关键点是对细节和边界条件的处理。这道题目基本是反转链表的变形。
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { if (head == nullptr) return head; using lp = ListNode*; lp t1, t2, tmp, t3 = head, pt = nullptr; int cnt = 0; while (true &amp;&amp; t3 !">
<meta itemprop="datePublished" content="2019-12-12T19:05:00&#43;08:00" />
<meta itemprop="dateModified" content="2019-12-30T16:58:45&#43;08:00" />
<meta itemprop="wordCount" content="200">



<meta itemprop="keywords" content="LeetCode,algorithm,hard," />

<link rel="stylesheet" href="/css/layout.css" />


<link rel="stylesheet" href="/css/default-dark.css" />



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-153304618-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<title>


     LeetCode 25. K 个一组翻转链表 

</title>

</head>


<body>
<div class="main">
<header>

<div class="header-bar">

  <nav>
    <div class="siteTitle">
      <a href="/">Do sth. Slowly</a>
    </div> 

    
    
    <a class="nav-item" href="/post/"><div class="nav-item-title">Posts</div></a>
    
    <a class="nav-item" href="/about/"><div class="nav-item-title">About</div></a>
    
    <a class="nav-item" href="/series"><div class="nav-item-title">Series</div></a>
    

  </nav>

  
<div class="social-links-header">

  
  <a href="mailto:thanks_music163@163.com"><div class="social-link">email</div></a>
  

  
  <a href="https://github.com/4q4" target="_blank"><div class="social-link">gh</div></a>
  

  

  

  

</div>


</div>


</header>


<article class="post">
    <h1 class="title"> LeetCode 25. K 个一组翻转链表 </h1>
    <div class="content"> <blockquote>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>示例 :</p>
<p>给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<p>说明 :</p>
<p>你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>来源：力扣（LeetCode）链接：<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group">https://leetcode-cn.com/problems/reverse-nodes-in-k-group</a>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>做这道题目的时候错了几次，这道题目不难，关键点是对细节和边界条件的处理。这道题目基本是反转链表的变形。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Definition for singly-linked list.
</span><span style="color:#75715e"> * struct ListNode {
</span><span style="color:#75715e"> *     int val;
</span><span style="color:#75715e"> *     ListNode *next;
</span><span style="color:#75715e"> *     ListNode(int x) : val(x), next(NULL) {}
</span><span style="color:#75715e"> * };
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  ListNode<span style="color:#f92672">*</span> reverseKGroup(ListNode<span style="color:#f92672">*</span> head, <span style="color:#66d9ef">int</span> k) {
    <span style="color:#66d9ef">if</span> (head <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>) <span style="color:#66d9ef">return</span> head;
    <span style="color:#66d9ef">using</span> lp <span style="color:#f92672">=</span> ListNode<span style="color:#f92672">*</span>;
    lp t1, t2, tmp, t3 <span style="color:#f92672">=</span> head, pt <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> (true <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> t3 <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>)
      {
	t2 <span style="color:#f92672">=</span> t1 <span style="color:#f92672">=</span> t3;
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
	  {
	    t2 <span style="color:#f92672">=</span> t2<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>next;
	    <span style="color:#66d9ef">if</span> (t2 <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>) <span style="color:#66d9ef">break</span>;
	  }
	<span style="color:#66d9ef">if</span> (t2 <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>) {
	  <span style="color:#66d9ef">if</span> (pt <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>)
	    pt<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>next <span style="color:#f92672">=</span> t1;
	  <span style="color:#66d9ef">break</span>;
	}
	<span style="color:#66d9ef">if</span> (pt <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>)
	  pt<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>next <span style="color:#f92672">=</span> t2;

	<span style="color:#66d9ef">if</span> (t1 <span style="color:#f92672">=</span><span style="color:#f92672">=</span> head)
	  head <span style="color:#f92672">=</span> t2;
	t3 <span style="color:#f92672">=</span> t2<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>next;

	lp p1, p2, p3;
	p1 <span style="color:#f92672">=</span> t1;
	p2 <span style="color:#f92672">=</span> p1<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>next;

	<span style="color:#66d9ef">while</span> (p1 <span style="color:#f92672">!</span><span style="color:#f92672">=</span> t2)
	  {
	    p3 <span style="color:#f92672">=</span> p2<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>next;
	    p2<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>next <span style="color:#f92672">=</span> p1;
	    p1 <span style="color:#f92672">=</span> p2;
	    p2 <span style="color:#f92672">=</span> p3;
	  }
	pt <span style="color:#f92672">=</span> t1;

	<span style="color:#66d9ef">if</span> (t3 <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>)
	  {
	    pt<span style="color:#f92672">-</span><span style="color:#f92672">&gt;</span>next <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
	    <span style="color:#66d9ef">break</span>;
	  }
      }

    <span style="color:#66d9ef">return</span> head;
  }
};
</code></pre></div><p>这种题目应该达到的程度是：一次写对，能够考虑到所有的边界条件，然而我现在还不能做到，之后（等把现在的做法忘记了之后）试一试。</p>
 </div>
    <footer class="post-footer">

  <div class="post-footer-data">
    
<div class="tags">
    
      <div class="tag">
        <a href="/tags/leetcode">#LeetCode</a>
      </div>
    
      <div class="tag">
        <a href="/tags/algorithm">#algorithm</a>
      </div>
    
      <div class="tag">
        <a href="/tags/hard">#hard</a>
      </div>
    
</div>

    <div class="date"> 12 Dec 2019 </div>
  </div>

</footer>


  <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "do-sth-slowly" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</article>

  <footer>

  <div class="social-links-footer">

  
  <a href="mailto:thanks_music163@163.com"><div class="social-link">Email</div></a>
  

  
  <a href="https://github.com/4q4" target="_blank"><div class="social-link">GitHub</div></a>
  

  

  

  

  <div class="social-link">
  <a href="/index.xml" target="_blank">RSS</a>
  </div>

</div>


  <div class="copyright">  </div>

  <div class="poweredby">
    Powered by <a href="https://gohugo.io/">Hugo</a>.
  </div>

  </footer>

</div> 

</body>
</html>

